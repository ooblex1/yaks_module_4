https://thayer.github.io/engs50/Notes/bash2/
2
37906
<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>More about Bash</title>
  <meta name="description" content="In Engs 50 you will learn how to design & build large, reliable, maintainable, and understandable software systems.  In the process you will learn to program in C with Unix development tools.
">

  <link rel="shortcut icon" href="/engs50/50.png" />
  <link rel="stylesheet" href="/engs50/css/main.css">
  <link rel="canonical" href="/engs50/Notes/bash2/">
</head>


  <body>

    <header class="site-header">

    <a class="site-title" href="/engs50/">
      <img width=48 align=center src="/engs50/50.png" alt="icon">
      Engs50 (CS50)
    </a>

    <nav class="site-nav">
      [<a href="/engs50/Labs/">Labs</a>]
      [<a href="/engs50/Notes/">Notes</a>]
      [<a href="/engs50/Reading/">Reading</a>]
      [<a href="/engs50/Resources/">Resources</a>]
			[<a href="/engs50/Examples/">Examples</a>]
   </nav>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">More about Bash</h1>
  </header>

  <div class="post-content">
    <p>Don’t forget this week’s <a href="/engs50/Reading/#week-1">reading</a>.</p>

<p>In this lecture, we continue our discussion of the Unix shell and its commands.</p>

<h2 id="goals">Goals</h2>

<p>We plan to learn the following today:</p>

<ul>
  <li>Redirection and pipes</li>
  <li>Special characters and quoting</li>
  <li>Standard input, output, and error</li>
</ul>

<p>We’ll do this activity in today’s class:</p>

<ul>
  <li>Sit with your group, and get to know your group mates.</li>
  <li>Experiment with shell pipelines in this <a href="activity.html">Activity</a>.</li>
</ul>

<h3 id="class-scripts">Class scripts</h3>

<p>I recorded my Terminal windows from <a href="/engs50/Notes/bash2/script-flume.txt">flume</a> and <a href="/engs50/Notes/bash2/script-mac.txt">Mac</a>.</p>

<h2 id="redirection-and-pipes">Redirection and pipes</h2>

<p>To date we have seen Unix programs using default input and output -
called <em>standard input</em> (stdin) and <em>standard output</em> (stdout) - the
keyboard is the standard input and the display the standard output.
The Unix shell is able to redirect both the input and output of
programs.  As an example of output redirection consider the following.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>date <span class="o">&gt;</span> listing
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lR</span> public_html/ <span class="o">&gt;&gt;</span> listing
</code></pre></div></div>

<p>The output redirection <code class="highlighter-rouge">&gt;</code> writes the output of <code class="highlighter-rouge">date</code> to the file
called <code class="highlighter-rouge">listing</code>; that is, the ‘standard output’ of the <code class="highlighter-rouge">date</code> process
has been directed to the file instead of the default, the display.
Note that the <code class="highlighter-rouge">&gt;</code> operation created a file that did not exist before
the output redirection command was executed.  Next, we append a
recursive, long-format directory listing to the same file; by using
the <code class="highlighter-rouge">&gt;&gt;</code> (double <code class="highlighter-rouge">&gt;</code>) we tell the shell to <em>append</em> to the file rather
than overwriting the file.</p>

<p>Note that the <code class="highlighter-rouge">&gt;</code> or <code class="highlighter-rouge">&gt;&gt;</code> and their target filenames are <em>not</em>
arguments to the command - the command simply writes to stdout, as it
always does, but the shell has arranged for stdout to be directed to a
file instead of the terminal.</p>

<p>The shell also supports input redirection.  This provides input to a
program (rather than the keyboard).  Let’s create a file of prime
numbers using output redirection.  The input to the <code class="highlighter-rouge">cat</code> command can
come from the standard input (i.e., the keyboard).  We can instruct
the shell to redirect the <code class="highlighter-rouge">cat</code> command’s output (stdout) to file
named <code class="highlighter-rouge">primes</code>.  The numbers are input at the keyboard and <code class="highlighter-rouge">CTRL-D</code> is
used to signal the end of the file (<code class="highlighter-rouge">EOF</code>).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> primes
61
53
41
2
3
11
13
18
37
5
19
23
29
31
47
53
59
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span> 
</code></pre></div></div>

<p>Input redirection <code class="highlighter-rouge">&lt;</code> tells the shell to use a file as input to the command rather than the keyboard.
In the input redirection example below <code class="highlighter-rouge">primes</code> is used as input to <code class="highlighter-rouge">cat</code> which sends its standard output to the screen.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">cat</span> &lt; primes
61
53
41
2
3
11
13
18
37
5
19
23
29
31
47
53
59
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>

<p>Many Unix commands (e.g., <code class="highlighter-rouge">cat</code>, <code class="highlighter-rouge">sort</code>) allow you to provide input from stdin if you do not specify a file on the command line.
For example, if you type <code class="highlighter-rouge">cat (CR)</code> (carriage return) then the command expects input from the standard input.</p>

<p>Unix also supports a powerful ‘pipe’ operator for passing data between commands using the operator <code class="highlighter-rouge">|</code> (a vertical bar, usually located above the <code class="highlighter-rouge">\</code> key on your keyboard).
Pipes connect commands that run as separate processes as data becomes available the processes are scheduled.</p>

<blockquote>
  <p>Pipes were invented by Doug McIlroy while he was working with Ken Thompson and Dennis Ritchie at AT&amp;T Bell Labs.
(As I mentioned earlier, Doug has been an adjunct professor here at Dartmouth College for several years now.)  In this <a href="/engs50/Reading/DougMcIlroy.pdf">two-page interview</a>, at the middle of the third column, Doug tells how pipes were invented and the <code class="highlighter-rouge">|</code> character selected as the operator.
Pay special attention to the next paragraph: the Dartmouth Time Sharing System had something similar, even earlier!</p>
</blockquote>

<p>Pipes are a clever invention indeed, since the need for separate temporary files for sharing data between processes is not required.
Because commands are implemented as processes, a program reading an empty pipe will be ``suspended’’ until there is data or information ready for it to read.
There is no limit to the number of programs or commands in the pipeline.
In our example below there are four programs in the pipeline all running simultaneously waiting on the input:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>sort <span class="nt">-n</span> primes | uniq | <span class="nb">grep</span> <span class="nt">-v</span> 18 | more
2
3
5
11
13
19
23
29
31
37
41
47
53
59
61
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>

<p>What is the difference between pipes and redirection?
Basically, redirection (<code class="highlighter-rouge">&gt;</code>,<code class="highlighter-rouge">&gt;&gt;</code>,<code class="highlighter-rouge">&lt;</code>) is used to direct the stdout of command to a file, or from a file to the stdin of a command.
Pipes (<code class="highlighter-rouge">|</code>) are used to redirect the stdout to the stdin of another command.
This operator allows us to ‘glue’ together programs as ‘filters’ to process the plain text sent between them (<em>plain text</em> between the processes - a nice design decision).
This supports the notion of reuse and allows us to build sophisticated programs quickly and simply.
It’s another cool feature of Unix.</p>

<p>Notice three new commands above: <code class="highlighter-rouge">sort</code>, <code class="highlighter-rouge">uniq</code>, and <code class="highlighter-rouge">grep</code>.</p>

<ul>
  <li><code class="highlighter-rouge">sort</code> reads lines from from stdin and outputs the lines in sorted order; here <code class="highlighter-rouge">-n</code> tells `sort to use numeric order (rather than alphabetical order);</li>
  <li><code class="highlighter-rouge">uniq</code> removes duplicates, printing only one of a run of identical lines;</li>
  <li><code class="highlighter-rouge">grep</code> prints lines matching a pattern (more generally, a <em>regular expression</em>); here, <code class="highlighter-rouge">-v</code> inverts this behavior: print lines that <em>do not</em> match the pattern.
In this case, the pattern is simply <code class="highlighter-rouge">18</code> and <code class="highlighter-rouge">grep</code> does not print that number as it comes through.</li>
</ul>

<p>And, as we saw last time, <code class="highlighter-rouge">more</code> pauses the output when it would scroll off the screen.</p>

<p>Note that the original file - <code class="highlighter-rouge">primes</code> - is not changed by executing the command line above.
Rather, the file is read in by the <code class="highlighter-rouge">sort</code> command and the data is manipulated as it is processed by each stage of the command pipe line.
Because <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">cat</code> are happy to read its input data from stdin, or from a file given as an argument, the following pipelines all achieve the same result:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>sort <span class="nt">-n</span> &lt; primes       | uniq | <span class="nb">grep</span> <span class="nt">-v</span> 18 | more
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">cat   </span>primes | sort <span class="nt">-n</span> | uniq | <span class="nb">grep</span> <span class="nt">-v</span> 18 | more
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">cat</span> &lt; primes | sort <span class="nt">-n</span> | uniq | <span class="nb">grep</span> <span class="nt">-v</span> 18 | more
</code></pre></div></div>

<p>Which do you think would be most efficient?</p>

<p><strong>Another pipeline</strong>: How did I create that list of existing usernames, for Lab0?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>cut <span class="nt">-d</span> : <span class="nt">-f</span> 1 /etc/passwd | sort <span class="o">&gt;</span> usernames.txt
</code></pre></div></div>

<blockquote>
  <p>See <code class="highlighter-rouge">man cut</code> to understand what the first command does.</p>
</blockquote>

<p><strong>Another example</strong>: what is the most popular shell?
Try each of these in turn:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>cut <span class="nt">-d</span> : <span class="nt">-f</span> 7 /etc/passwd
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>cut <span class="nt">-d</span> : <span class="nt">-f</span> 7 /etc/passwd | less
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>cut <span class="nt">-d</span> : <span class="nt">-f</span> 7 /etc/passwd | sort
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>cut <span class="nt">-d</span> : <span class="nt">-f</span> 7 /etc/passwd | sort | uniq <span class="nt">-c</span>
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>cut <span class="nt">-d</span> : <span class="nt">-f</span> 7 /etc/passwd | sort | uniq <span class="nt">-c</span> | sort <span class="nt">-n</span>
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>cut <span class="nt">-d</span> : <span class="nt">-f</span> 7 /etc/passwd | sort | uniq <span class="nt">-c</span> | sort <span class="nt">-nr</span>
</code></pre></div></div>

<h3 id="macos-tip">MacOS tip:</h3>

<p>There are three great commands you should know - they are not on Linux, because they interact with MacOS: <code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">pbpaste</code>, <code class="highlighter-rouge">pbcopy</code>.</p>

<p>You’ve already seen the <code class="highlighter-rouge">open</code> command, which on MacOS at the Terminal command line, will open a file for viewing in the relevant MacOS application; for example, for a photo file you might type <code class="highlighter-rouge">open photo.jpg</code> and see Preview launch and open that file; for an html file you might type <code class="highlighter-rouge">open index.html</code> and see Safari launch and render that page.</p>

<p>The commands <code class="highlighter-rouge">pbpaste</code> and <code class="highlighter-rouge">pbcopy</code> are a great fit into many pipelines.
The first command prints the MacOS ‘clipboard’ to its standard output, and the second copies its standard input into the MacOS clipboard.
For example; select some text in a window somewhere, then <em>cmd-C</em> to copy it to the clipboard, then</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	pbpaste | wc
</code></pre></div></div>
<p>to count the lines, words, and characters in the clipboard.
Or,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	ls -l | pbcopy
</code></pre></div></div>
<p>saves the directory listing in the clipboard, where you might paste it into Piazza or an email message or some document.</p>

<p>I’m not certain you can combine <code class="highlighter-rouge">pbpaste</code> and <code class="highlighter-rouge">pbcopy</code> on the same command line, however; if you wanted to <em>replace</em> the clipboard with its number of lines, you might try</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	pbpaste | wc -l | pbcopy
</code></pre></div></div>
<p>but be careful mixing those two commands.</p>

<h2 id="standard-input-output-and-error">Standard input, output and error</h2>

<p>As we learned above, every process (a running program) has a <em>standard input</em> (abbreviated
to <code class="highlighter-rouge">stdin</code>) and a <em>standard output</em> (<code class="highlighter-rouge">stdout</code>). 
The shell sets <code class="highlighter-rouge">stdin</code> to the keyboard by default, but the command
line can tell the shell to redirect <code class="highlighter-rouge">stdin</code> using <code class="highlighter-rouge">&lt;</code> or a pipe.  The
shell sets <code class="highlighter-rouge">stdout</code> to the display by default, but the command line
can tell the shell to redirect <code class="highlighter-rouge">stdout</code> using <code class="highlighter-rouge">&gt;</code> or <code class="highlighter-rouge">&gt;&gt;</code>, or to a
pipe.</p>

<p>Each process also has a <em>standard error</em> (<code class="highlighter-rouge">stderr</code>), which most
programs use for printing error messages.  The separation of <code class="highlighter-rouge">stdout</code>
and <code class="highlighter-rouge">stderr</code> is important when <code class="highlighter-rouge">stdin</code> is redirected to a file or
pipe, because normal output can flow into the file or pipe while error
messages reach the user on the screen.</p>

<p>Inside the running process these three streams are represented with
numeric <em>file descriptors</em>:</p>

<ol>
  <li><code class="highlighter-rouge">stdin</code></li>
  <li><code class="highlighter-rouge">stdout</code></li>
  <li><code class="highlighter-rouge">stderr</code></li>
</ol>

<p>You can tell the shell to redirect using these numbers; <code class="highlighter-rouge">&gt;</code> is
shorthand for <code class="highlighter-rouge">1&gt;</code> and <code class="highlighter-rouge">&lt;</code> is shorthand for <code class="highlighter-rouge">0&lt;</code>.  You can thus
redirect the standard error (file descriptor 2) with the symbol <code class="highlighter-rouge">2&gt;</code>.
Suppose I was logged in as <code class="highlighter-rouge">dfk</code> and wanted to make a list of the web
files <code class="highlighter-rouge">index.html</code> anywhere in the <code class="highlighter-rouge">cs50</code> account’s home directory
tree.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>find ~cs50 <span class="nt">-name</span> index.html <span class="o">&gt;</span> pages
find: <span class="sb">`</span>/net/class/cs50/Archive/src<span class="s1">': Permission denied
find: `/net/class/cs50/.emacs.d'</span>: Permission denied
find: <span class="sb">`</span>/net/class/cs50/private/<span class="s1">': Permission denied
[engs50@mc ~]$ 
</span></code></pre></div></div>

<p>I redirected the output of <code class="highlighter-rouge">find</code> to a file called <code class="highlighter-rouge">pages</code> - and
indeed that file filled with useful information - but <code class="highlighter-rouge">find</code> printed
its error messages to the screen so I could still see them.  Suppose I
wanted to capture those errors in a file too:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>find ~cs50 <span class="nt">-name</span> index.html <span class="o">&gt;</span> pages 2&gt; errors
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>
<p>The file <code class="highlighter-rouge">errors</code> contains the error messages we saw earlier.</p>

<p>As another alternative, we could ignore the error output entirely by
sending it to a place where all characters go and never return!</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>find ~cs50 <span class="nt">-name</span> index.html <span class="o">&gt;</span> pages 2&gt; /dev/null
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>
<p>The file called <code class="highlighter-rouge">/dev/null</code> is a special kind of file - it’s not a file at all,
actually, it’s a ‘device’ that simply discards anything written to it.
(If you read from it, it appears to be an empty file.)</p>

<h2 id="special-characters">Special characters</h2>

<p>There are a number of special characters interpreted by the shell -
spaces, tabs, wildcard (‘globbing’) characters for filename expansion,
redirection symbols, and so forth.  Special characters have special
meaning and cannot be used as regular characters because the shell
interprets them in a special manner.  These special characters
include:</p>

<p><code class="highlighter-rouge">&amp; ; | * ?  ` " ' [ ] ( ) $ &lt; &gt; { } # / \ ! ~</code></p>

<p>We have already used several of these special characters.
Don’t try to memorize them at this stage.
Through use, they will become second nature.
We will just give some examples of the ones we have not discussed so far.</p>

<h2 id="quoting">Quoting</h2>

<p>If you need to use one of these special characters as a regular
character, you can tell the shell not to interpret it by escaping or
quoting it.  To <em>escape</em> a single special character, precede it with a
backslash <code class="highlighter-rouge">\</code>; earlier we saw how to escape the character <code class="highlighter-rouge">*</code> with
<code class="highlighter-rouge">\*</code>.  To escape multiple special characters (as in <code class="highlighter-rouge">**</code>), quote each:
<code class="highlighter-rouge">\*\*</code>.  You can also <em>quote</em> using single quotation marks such as
<code class="highlighter-rouge">'**'</code> or double quotation marks such as <code class="highlighter-rouge">"**"</code> - but these have
subtlety different behavior.  You might use this form when quoting a
filename with embedded spaces: <code class="highlighter-rouge">"Homework assignment"</code>.</p>

<p>You will often need to pass special characters as part of arguments to
commands and other programs - for example, an argument that represents
a pattern to be interpreted by the command; as happens often with
<code class="highlighter-rouge">find</code> and <code class="highlighter-rouge">grep</code>.</p>

<p>There is a situation where single quotes work differently than double
quotes.  If you use a pair of single quotes around a shell variable
substitution (like <code class="highlighter-rouge">$USER</code>), the variable’s value will not be
substituted, whereas it would be substituted within double quotes:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$LOGNAME</span><span class="s2"> uses the </span><span class="nv">$SHELL</span><span class="s2"> shell and his home directory is </span><span class="nv">$HOME</span><span class="s2">."</span>
cs50 uses the /bin/bash shell and his home directory is /net/class/cs50.
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'$LOGNAME uses the $SHELL shell and his home directory is $HOME.'</span>
<span class="nv">$LOGNAME</span> uses the <span class="nv">$SHELL</span> shell and his home directory is <span class="nv">$HOME</span><span class="nb">.</span>
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>

<p><strong><em>Example 1.</em></strong>
Double-quotes are especially important in shell scripts, because the
variables involved might have been user input (a command-line argument
or a keyboard input) or might have be a file name or output of a
command; such variables should <em>always</em> be quoted when substituted,
because spaces (and other special characters) embedded in the value of
the variable can cause confusion.  Thus:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">directoryName</span><span class="o">=</span><span class="s2">"Homework three"</span>
...
mkdir <span class="s2">"</span><span class="nv">$directoryName</span><span class="s2">"</span>
mkdir <span class="nv">$directoryName</span>
</code></pre></div></div>

<p>Try it!</p>

<p><strong><em>Example 2.</em></strong>
Escapes and quoting can pass special characters and patterns passed to
commands.</p>

<p>Suppose I have a list of email addresses, one per line.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Eric Chen &lt;eric.t.chen.17@dartmouth.edu&gt;
 Rui Liu &lt;Rui.Liu.GR@dartmouth.edu&gt;
 Taylor Hardin &lt;Taylor.A.Hardin.GR@dartmouth.edu&gt;
 Elena N. Horton &lt;Elena.N.Horton.18@dartmouth.edu&gt;
 Jinnan Ge &lt;Jinnan.Ge.TH@dartmouth.edu&gt;
 Mauricio Esquivel Rogel &lt;Mauricio.Esquivel.Rogel.18@dartmouth.edu&gt;
 James Edwards &lt;James.G.Edwards.18@dartmouth.edu&gt;
 Emily J. Lin &lt;Emily.J.Lin.18@dartmouth.edu&gt;
 John Cardwell &lt;John.R.Cardwell.18@dartmouth.edu&gt;
 John Kotz &lt;John.P.Kotz.19@dartmouth.edu&gt;
 Joel J. Katticaran &lt;joel.j.katticaran.ug@dartmouth.edu&gt;
 Kaya M. Thomas &lt;Kaya.M.Thomas.17@dartmouth.edu&gt;
 Trevor L. Davis &lt;trevor.l.davis.18@dartmouth.edu&gt;
 Thomas D. Kim &lt;Thomas.D.Kim.19@dartmouth.edu&gt;
 Kyle Dotterrer &lt;kyle.dotterrer.18@dartmouth.edu&gt;
</code></pre></div></div>

<p>Some email programs, or websites, require these to be comma-separated.
If I have the above text in my clipboard, I can change those newline characters to commas:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pbpaste | tr <span class="se">\\</span>n ,
Eric Chen &lt;eric.t.chen.17@dartmouth.edu&gt;, Rui Liu &lt;Rui.Liu.GR@dartmouth.edu&gt;, Taylor Hardin &lt;Taylor.A.Hardin.GR@dartmouth.edu&gt;, Elena N. Horton &lt;Elena.N.Horton.18@dartmouth.edu&gt;, Jinnan Ge &lt;Jinnan.Ge.TH@dartmouth.edu&gt;, Mauricio Esquivel Rogel &lt;Mauricio.Esquivel.Rogel.18@dartmouth.edu&gt;, James Edwards &lt;James.G.Edwards.18@dartmouth.edu&gt;, Emily J. Lin &lt;Emily.J.Lin.18@dartmouth.edu&gt;, John Cardwell &lt;John.R.Cardwell.18@dartmouth.edu&gt;, John Kotz &lt;John.P.Kotz.19@dartmouth.edu&gt;, Joel J. Katticaran &lt;joel.j.katticaran.ug@dartmouth.edu&gt;, Kaya M. Thomas &lt;Kaya.M.Thomas.17@dartmouth.edu&gt;, Trevor L. Davis &lt;trevor.l.davis.18@dartmouth.edu&gt;, Thomas D. Kim &lt;Thomas.D.Kim.19@dartmouth.edu&gt;, Kyle Dotterrer &lt;kyle.dotterrer.18@dartmouth.edu&gt; 
</code></pre></div></div>

<blockquote>
  <p>On Unix a single special character called ‘newline’ is what <em>defines</em> the end of one line and the beginning of the next.
A common syntax for the newline character, in programming languages,
is <code class="highlighter-rouge">\n</code>.  But the <code class="highlighter-rouge">\</code> is special, in bash, so we need to escape it,
um, with <code class="highlighter-rouge">\</code>; thus we have <code class="highlighter-rouge">\\n</code>.</p>
</blockquote>

<p>The <code class="highlighter-rouge">tr</code> command filters <code class="highlighter-rouge">stdin</code> to <code class="highlighter-rouge">stdout</code>, translates each instance
of the character given in the first argument (<code class="highlighter-rouge">\\n</code>) to the character
given in the second argument (<code class="highlighter-rouge">,</code>).  Here, <code class="highlighter-rouge">tr</code> spit out the
translated input - on one very long line that does not end with a
newline.  I can then copy-paste that result into the pesky web
browser.</p>

<p>Outlook and Microsoft tools want <em>semicolons</em>, not commas; sigh.
But the semicolon is also special to bash; so we must escape it too:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tr <span class="se">\\</span>n <span class="se">\;</span>
</code></pre></div></div>

<p>On MacOS I can connect the MacOS “Clipboard” to this tool as follows:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pbpaste | tr <span class="se">\\</span>n <span class="se">\;</span> | pbcopy
</code></pre></div></div>
<p>great!
copy the list of addresses to the clipboard, type that command in the shell, and now the clipboard contains a semicolon-separated list of addresses.</p>

<p><strong><em>Example 3.</em></strong>
An even more powerful filtering tool - the stream editor called
<code class="highlighter-rouge">sed</code> - allows you to transform occurrences of one or more patterns in
the input file(s):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	sed pattern <span class="o">[</span>file]...  
</code></pre></div></div>

<p>For example,</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">cat</span> .forward
 David Kotz &lt;kotz@cs&gt;
 Eric Chen &lt;eric.t.chen.17@dartmouth.edu&gt;
 Rui Liu &lt;Rui.Liu.GR@dartmouth.edu&gt;
 Taylor Hardin &lt;Taylor.A.Hardin.GR@dartmouth.edu&gt;
 Elena N. Horton &lt;Elena.N.Horton.18@dartmouth.edu&gt;
 Jinnan Ge &lt;Jinnan.Ge.TH@dartmouth.edu&gt;
 Mauricio Esquivel Rogel &lt;Mauricio.Esquivel.Rogel.18@dartmouth.edu&gt;
 James Edwards &lt;James.G.Edwards.18@dartmouth.edu&gt;
 Emily J. Lin &lt;Emily.J.Lin.18@dartmouth.edu&gt;
 John Cardwell &lt;John.R.Cardwell.18@dartmouth.edu&gt;
 John Kotz &lt;John.P.Kotz.19@dartmouth.edu&gt;
 Joel J. Katticaran &lt;joel.j.katticaran.ug@dartmouth.edu&gt;
 Kaya M. Thomas &lt;Kaya.M.Thomas.17@dartmouth.edu&gt;
 Trevor L. Davis &lt;trevor.l.davis.18@dartmouth.edu&gt;
 Thomas D. Kim &lt;Thomas.D.Kim.19@dartmouth.edu&gt;
 Kyle Dotterrer &lt;kyle.dotterrer.18@dartmouth.edu&gt;
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="c"># remove myself, and excess white space</span>
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>sed <span class="nt">-e</span> /kotz@cs/d <span class="nt">-e</span> <span class="s1">'s/\t/ /g'</span> <span class="nt">-e</span> <span class="s1">'s/  */ /g'</span>  .forward
 Eric Chen &lt;eric.t.chen.17@dartmouth.edu&gt;
 Rui Liu &lt;Rui.Liu.GR@dartmouth.edu&gt;
 Taylor Hardin &lt;Taylor.A.Hardin.GR@dartmouth.edu&gt;
 Elena Horton &lt;Elena.N.Horton.18@dartmouth.edu&gt;
 Jinnan Ge &lt;Jinnan.Ge.TH@dartmouth.edu&gt;
 Mauricio Esquivel Rogel &lt;Mauricio.Esquivel.Rogel.18@dartmouth.edu&gt;
 James Edwards &lt;James.G.Edwards.18@dartmouth.edu&gt;
 Emily Lin &lt;Emily.J.Lin.18@dartmouth.edu&gt;
 John Cardwell &lt;John.R.Cardwell.18@dartmouth.edu&gt;
 John Kotz &lt;John.P.Kotz.19@dartmouth.edu&gt;
 Joel Katticaran &lt;joel.j.katticaran.ug@dartmouth.edu&gt;
 Kaya Thomas &lt;Kaya.M.Thomas.17@dartmouth.edu&gt;
 Trevor Davis &lt;trevor.l.davis.18@dartmouth.edu&gt;
 Thomas Kim &lt;Thomas.D.Kim.19@dartmouth.edu&gt;
 Kyle Dotterrer &lt;kyle.dotterrer.18@dartmouth.edu&gt;
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="c"># remove myself, remove names, make comma-sep list of addresses</span>
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>sed <span class="nt">-e</span> /kotz@cs/d <span class="nt">-e</span> <span class="s1">'s/.*&lt;//'</span> <span class="nt">-e</span> <span class="s1">'s/&gt;.*/,/'</span>  .forward
eric.t.chen.17@dartmouth.edu,
Rui.Liu.GR@dartmouth.edu,
Taylor.A.Hardin.GR@dartmouth.edu,
Elena.N.Horton.18@dartmouth.edu,
Jinnan.Ge.TH@dartmouth.edu,
Mauricio.Esquivel.Rogel.18@dartmouth.edu,
James.G.Edwards.18@dartmouth.edu,
Emily.J.Lin.18@dartmouth.edu,
John.R.Cardwell.18@dartmouth.edu,
John.P.Kotz.19@dartmouth.edu,
joel.j.katticaran.ug@dartmouth.edu,
Kaya.M.Thomas.17@dartmouth.edu,
trevor.l.davis.18@dartmouth.edu,
Thomas.D.Kim.19@dartmouth.edu,
kyle.dotterrer.18@dartmouth.edu,
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>

<p>The above uses the <code class="highlighter-rouge">-e</code> switch to <code class="highlighter-rouge">sed</code>, which allows one to list more than one pattern on the same command.</p>

<p>A few quick notes about sed’s patterns:</p>

<ul>
  <li><code class="highlighter-rouge">d</code> deletes lines matching the pattern</li>
  <li><code class="highlighter-rouge">p</code> prints lines matching the pattern (useful with <code class="highlighter-rouge">-n</code>)</li>
  <li><code class="highlighter-rouge">s</code> substitutes text for matches to the pattern.</li>
</ul>

<p>Patterns are actually <a href="http://sed.sourceforge.net/sedfaq3.html#s3.1.1">regular expressions</a>; I use some above.</p>

<p><strong><em>Example 4.</em></strong></p>

<p>I saved a list of students enrolled in CS50 in the file <code class="highlighter-rouge">~cs50/demo/students.txt</code>.
Each line is of the form <code class="highlighter-rouge">First.M.Last.18@Dartmouth.edu;</code>.</p>

<p>Let’s suppose you all decide to move to Harvard.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>sed s/Dartmouth/Harvard/ demo/students.txt
...
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>sed <span class="nt">-e</span> s/Dartmouth/Harvard/ <span class="nt">-e</span> <span class="s1">'s/\.[0-9][0-9]//'</span> <span class="nt">-e</span> <span class="s1">'s/;$//'</span> demo/students.txt
...
</code></pre></div></div>

<p>The second form removes the dot and two-digit class number, and the
trailing semicolon.  Notice how I quoted those patterns from the
shell, and even escaped the dot from sed’s normal meaning (dot matches
any character) so sed would look for a literal dot in that position.
The dollar <code class="highlighter-rouge">$</code> constrains the semicolon match to happen at the end of
the line.</p>

<p>Here’s another fun pipe: count the number of students from each class
(leveraging the class numbers in email addresses):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>tr <span class="nt">-c</span> <span class="nt">-d</span> 0-9<span class="se">\\</span>n &lt; demo/students.txt | sed <span class="s1">'s/^$/other/'</span>  | sort  | uniq <span class="nt">-c</span> | sort <span class="nt">-nr</span>
     27 18
     22 19
      9 17
      5 other
      1 16
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>

<p>See <code class="highlighter-rouge">man sed</code> or the <a href="http://sed.sourceforge.net/sedfaq.html">sed FAQ</a> for more info.
You’ll want to learn a bit about <em>regular expressions</em>, which are used to describe patterns in sed’s commands; 
see <a href="http://sed.sourceforge.net/sedfaq3.html#s3.1.1">sed regexp info</a>.</p>

<h2 id="compressing-and-archiving-files">Compressing and archiving files</h2>

<p>It is often useful to bundle several files into a compressed <em>archive</em> file.
You may have encountered files like this on the Internet - such as <code class="highlighter-rouge">files.zip</code>, <code class="highlighter-rouge">something.tar</code>, or <code class="highlighter-rouge">somethin-else.tgz</code>.
Each packs together several files - including directories, creation dates, access permissions, as well as file contents - into one single file.
This is a convenient way to transfer large collections of files.</p>

<p>On Unix it is most common to use the <code class="highlighter-rouge">tar</code> utility (short for tape archive - from back when we used tapes) to create an archive of all the files and directories listed in the arguments and name it to something appropriate.
We often ask <code class="highlighter-rouge">tar</code> to compress the resulting archive  too.</p>

<p>Given a directory <code class="highlighter-rouge">stuff</code>, you can create (<code class="highlighter-rouge">c</code>) a compressed tar archive (aka, a “tarball”), and then list (<code class="highlighter-rouge">t</code>) its contents.
The <code class="highlighter-rouge">f</code> refers to a file and the <code class="highlighter-rouge">z</code> refers to compression.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>mkdir stuff
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;</span> stuff/x
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">tar </span>cfz stuff.tgz stuff
 98.8%
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">tar </span>tfz stuff.tgz
stuff/
stuff/x
<span class="o">[</span>engs50@mc ~]<span class="nv">$ </span>
</code></pre></div></div>

<p>The command leaves the original directory and files intact.
Notice that <code class="highlighter-rouge">tar</code> has an unconventional syntax for its switches - there is no dash <code class="highlighter-rouge">-</code> before them.</p>

<p>To unpack the archive,</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>engs50@mc ~]<span class="nv">$ </span><span class="nb">tar </span>xfz stuff.tgz
</code></pre></div></div>

<p>In short, <code class="highlighter-rouge">c</code> for create, <code class="highlighter-rouge">t</code> for type (list), <code class="highlighter-rouge">x</code> for extract.
The <code class="highlighter-rouge">f</code> implies that the next argument is the tarball file name.
The <code class="highlighter-rouge">z</code> indicates that the tarball should be compressed.
By convention, a tarball filename ends in <code class="highlighter-rouge">.tar</code> if not compressed, <code class="highlighter-rouge">.tgz</code> if compressed.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Engs50 (CS50) -- Dartmouth College</h2>

    <p> <font size=-1>
    	This version of the course is based upon those designed by
    	Professors Palmer, Kotz, Zhou, Campbell, and Balkcom.
	I am deeply indebted to these outstanding educators.
    -- <a href="https://engineering.dartmouth.edu/people/faculty/stephen-taylor/">Stephen Taylor</a>
       </font>
    </p>
    <p><small>This page was last updated on <strong>2018-10-10</strong> at <strong>18:07</strong>.</small></p>
  </div>

</footer>


  </body>

</html>

