https://thayer.github.io/engs50/Notes/design/design.html
3
16101
<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Software design methodology</title>
  <meta name="description" content="In Engs 50 you will learn how to design & build large, reliable, maintainable, and understandable software systems.  In the process you will learn to program in C with Unix development tools.
">

  <link rel="shortcut icon" href="/engs50/50.png" />
  <link rel="stylesheet" href="/engs50/css/main.css">
  <link rel="canonical" href="/engs50/Notes/design/design.html">
</head>


  <body>

    <header class="site-header">

    <a class="site-title" href="/engs50/">
      <img width=48 align=center src="/engs50/50.png" alt="icon">
      Engs50 (CS50)
    </a>

    <nav class="site-nav">
      [<a href="/engs50/Labs/">Labs</a>]
      [<a href="/engs50/Notes/">Notes</a>]
      [<a href="/engs50/Reading/">Reading</a>]
      [<a href="/engs50/Resources/">Resources</a>]
			[<a href="/engs50/Examples/">Examples</a>]
   </nav>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Software design methodology</h1>
  </header>

  <div class="post-content">
    <h3 id="goals">Goals</h3>

<p>In this lecture, we introduce a simple software design methodology.
It’s by no means the only methodology - but it’s straightforward and useful for CS50.</p>

<blockquote>
  <p><em>All programmers are optimists</em> – Frederick P. Brooks, Jr.</p>
</blockquote>

<p>Here’s a cool source of thoughtful maxims for software development: <em>The Pragmatic Programmer</em>, by Andrew Hunt and David Thomas (2000, Addison Wesley).
Their book is super, and their <a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">“tip list” is available on the web</a>.
We sprinkle some of their tips throughout the lectures.</p>

<h2 id="software-system-design-methodology">Software system design methodology</h2>

<p>There are many techniques for the design and development of good code including top-down or bottom-up design; divide and conquer (breaking the system down into smaller more understandable components), structured design (data flow-oriented design approach), and object-oriented design (modularity, abstraction, and information-hiding).
For a quick survey of these and other techniques, see <em><a href="/engs50/Notes/design/survey.html">A Survey of Major Software Design Methodologies</a></em> (author unknown).</p>

<p>Many of these techniques use similar approaches, and embrace fundamental concepts like
abstraction,
data representation,
data flow,
data structures,
and
top-down decomposition from requirements to structure.</p>

<p>It seems unlikely that someone could give you 10 steps to follow and be assured of great system software.
Every non-trivial project has its special cases, unique environments, or unexpected uses.
It’s often best to begin development of a module, or a system, with small experiments - building a prototype and throwing it away - because you can learn (and make mistakes) building small prototype systems.</p>

<p><a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">Pragmatic Programmer Tip</a> :</p>
<blockquote>
  <p><strong>Prototype to Learn.</strong>
 Prototyping is a learning experience. Its value lies not in the code you produce, but in the lessons you learn.</p>
</blockquote>

<p>Clarity comes from the experience of working from requirements, through system design, implementation and testing, to integration and customer feedback on the requirements.</p>

<p>The following figure shows the software design methodology that we use in the design of the TinySearchEngine and the project.</p>

<p><img src="/engs50/Notes/design/SWDesignMethology.png" alt="Software system design methodology" /></p>

<hr />

<p>Let’s step through the phases of software design, as shown in the figure above.</p>

<h2 id="procurement-phase">Procurement phase</h2>

<p>The procurement phase of a project represents its early stages.
It represents deep discussion between a customer and provider of software systems.
As a software developer, you have to clearly understand and capture the customers’ needs.
In our case, you are the provider and we (CS50 staff) are your customer.</p>

<h3 id="requirements-spec">Requirements Spec</h3>

<p><a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">Pragmatic Programmer Tip</a> :</p>
<blockquote>
  <p><strong>Don’t Gather Requirements – Dig for Them.</strong>
 Requirements rarely lie on the surface. They’re buried deep beneath layers of assumptions, misconceptions, and politics.</p>
</blockquote>

<p>The system Requirements Spec captures all the requirements of the system that the customer wants built.
Typically the provider and customer get into deep discussion of requirements and their cost.
The requirements <em>must</em> be written down, and reviewed by both customer and provider, to be sure all are in agreement.
Sometimes these documents are written in contractual (legal) language.
If the customer gets a system that does not meet the spec, or the two parties disagree about whether the finished product meets the spec, lawyers may get involved.
If a system is late, financial penalties may arise.</p>

<blockquote>
  <p>“<em>The hardest part of design… is keeping features out.</em>” – Anonymous</p>
</blockquote>

<p>The system requirement spec may have a variety of requirements typically considered <strong>the SHALLS</strong> - such as, <em>“the crawler SHALL crawl 1000 sites in 5 minutes”</em>.
These requirements include functional requirements, performance requirements, security requirements, and cost requirements.</p>

<p>A common challenge during this phase is that the customer either doesn’t know what he/she really wants or expresses it poorly (in some extreme cases the customer may not be able to provide you with the ultimate intended use of your system due to proprietary or security concerns).
You must realize that the customer may have these difficulties and iterate with the customer until you both are in full agreement.
One useful technique is to provide the customer with the system requirements specification (and sometimes later specs too) and then have the customer explain the spec to us.
It is amazing how many misunderstandings and false assumptions come to light when the customer is doing the explaining.</p>

<p>The Requirements Spec may address many or all of the following issues:</p>

<ul>
  <li>functionality - what should the system do?</li>
  <li>performance - goals for speed, size, energy efficiency, etc.</li>
  <li>cost - goals for cost, if system operation incurs costs</li>
  <li>compliance - with federal/state law or institutional policy</li>
  <li>compatibility - with standards or with existing systems</li>
  <li>security - against a specific threat model under certain trust assumptions</li>
</ul>

<p>A new concern of system development is the issue of the services-oriented model referred to as the “cloud” (Software As A Service, Infrastructure As A Service, etc.).
The decision of whether to develop a specific system running in a traditional manner or to build a cloud-based solution should be made early, as it will affect many of the later stages of the development process.
Some would argue about where it needs to fit in the methodology, but we feel that the sooner you (and the customer) know where this system is headed, the better.</p>

<p><a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">Pragmatic Programmer Tip</a> :</p>
<blockquote>
  <p><strong>Make quality a requirements issue.</strong>
 Involve your users in determining the project’s real quality requirements.</p>
</blockquote>

<p>Although the customer may make some assumptions on this point, it’s in your best interests to make it a priority.
Remember the “broken window theory”.</p>

<p><a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">Pragmatic Programmer Tip</a> :</p>
<blockquote>
  <p><strong>Don’t Live with Broken Windows.</strong>
 Fix bad designs, wrong decisions, and poor code when you see them.</p>
</blockquote>

<h3 id="design-spec">Design Spec</h3>

<p>The <em>Design Spec</em> is the result of studying the system requirements and applying the art of design <em>(the magic)</em> with a design team.
In this phase, you translate the requirements into a full system-design specification.
This design specification shows how the complete system is broken up into specific subsystems, and all of the requirements are mapped to those subsystems.
The Design spec for a system, subsystem, or module includes:</p>

<ul>
  <li>User interface</li>
  <li>Inputs and outputs</li>
  <li>Functional decomposition into modules</li>
  <li>Dataflow through modules</li>
  <li>Pseudo code (plain English-like language) for logic/algorithmic flow</li>
  <li>Major data structures</li>
  <li>Testing plan</li>
</ul>

<p>To this last point:</p>

<p><a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">Pragmatic Programmer Tip</a> :</p>
<blockquote>
  <p><strong>Design to Test.</strong>
 Start thinking about testing before you write a line of code.</p>
</blockquote>

<p>The Design Specification is independent of your choice of language, operating system, and hardware.
In principle, it could be implemented in any language from Java to micro-code and run on anything from a Cray supercomputer to a toaster.</p>

<h2 id="implementation-phase">Implementation phase</h2>

<p>In this phase, we turn the Design Spec into an Implementation Spec, then code up the modules, unit-test each module, integrate the modules and test them as an integrated sub-system and then system.</p>

<h3 id="implementation-spec">Implementation Spec</h3>

<p>The <em>Implementation Spec</em> represents a further refinement and decomposition of the system.
It is language, operating system, and hardware <strong>dependent</strong> (in many cases, the language abstracts the OS and HW out of the equation but not in this course).
The implementation spec includes many or all of these topics:</p>

<ul>
  <li>Detailed pseudo code for each of the objects/components/functions,</li>
  <li>Definition of detailed APIs, interfaces, function prototypes and their parameters,</li>
  <li>Data structures (e.g., <code class="highlighter-rouge">struct</code> names and members),</li>
  <li>Security and privacy properties,</li>
  <li>Error handling and recovery,</li>
  <li>Resource management,</li>
  <li>Persistant storage (files, database, etc).</li>
</ul>

<h3 id="coding">Coding</h3>

<p>Coding is often the fun part of the software development cycle - but not usually the largest amount of time.
As a software developer in industry, you might spend only about 20% of your time coding (perhaps a lot more if you’re in a startup).
The rest of the time will be dealing with the other phases of the methodology, particularly, the last few: testing, integration, fixing problems with the product and meetings with your team and with your customers.</p>

<h4 id="goals-during-coding">Goals during coding:</h4>

<ul>
  <li>
    <p>Correctness: The program is correct (i.e., does it work) and error free. Duh.</p>
  </li>
  <li>
    <p>Clarity: The code is easy to read, well commented, and uses good variable and function names.
In essence, is it easy to use, understand, and maintain</p>

    <blockquote>
      <p>Clarity makes sure that the code is easy to understand by people with a range of skills, and across a variety of machine architectures and operating systems. [Kernighan &amp; Pike]</p>
    </blockquote>
  </li>
  <li>
    <p>Simplicity: The code is as simple as possible, but no simpler.</p>

    <blockquote>
      <p>Simplicity keeps the program short and manageable. [Kernighan &amp; Pike]</p>
    </blockquote>
  </li>
  <li>
    <p>Generality: The program can easily adapt to change.</p>

    <blockquote>
      <p>Generality means the code can work well in a broad range of situations and is tolerant of new environments (or can be easily made to do so). [Kernighan &amp; Pike]</p>
    </blockquote>
  </li>
</ul>

<h3 id="unit-and-sub-system-testing">Unit and sub-system testing</h3>

<p><a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">Pragmatic Programmer Tip</a> :</p>
<blockquote>
  <p><strong>Test your software, or your users will.</strong></p>
</blockquote>

<p>Testing is a critical part of the whole process of any development effort, whether you’re building bridges or software.
Unit testing of modules in isolation, and integration testing as modules are assembled into sub-systems and, ultimately, the whole system, result in better, safer, more reliable code.
We’ll talk more about testing soon.</p>

<p>The ultimate goal of testing is to exercise all paths through the code.
Of course, with most applications this may prove to be a daunting task.
Most of the time the code will execute a small set of the branches in the module.
So when special conditions occur and newly executed code paths fail, it can be really hard to find those problems in large complex pieces of code.</p>

<p>The better organized and modularized your code is, the easier it will be to understand, test, and maintain - even by you!</p>

<p>Write test scripts (tools) throughout the development process to quickly give confidence that even though 5% of new code has been added, no new bugs emerged because our test scripts assured of that.</p>

<h3 id="integration-testing">Integration testing</h3>

<p>The system is incrementally developed, put together and tested at various levels.
Subsystems could integrate many modules, and sometimes, new hardware.
The developer will run the integrated system against the original requirements to see if there are any ‘gotchas’.
For example, some performance requirements can only be tested once the full system comes together, while other, commonly used utility functions could have performance analysis done on them early on.
You can simulate external influences as well, such as increasing the external processing or communications load on the host system as a way to see how your program operates when the host system is heavily loaded or resource limited.</p>

<p>To quote the Pragmatic Programmer again:</p>
<blockquote>
  <p><a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">Pragmatic Programmer Tip</a> :
<strong>Don’t Think Outside the Box – Find the Box.</strong></p>
</blockquote>

<p>When faced with an impossible problem, identify the real constraints.
Ask yourself: “Does it have to be done this way? Does it have to be done at all?”</p>

<h2 id="feedback-phase">Feedback phase</h2>

<p>In this phase, the design team sits down with its customer and demonstrates its implementation.
The customer and the team review the original requirement spec and check each requirement for completion.</p>

<p>In the TSE and project we emphasize understanding the requirements of the system we want to build, writing good design and implementation specs <em>before</em> coding.
You shall apply the coding principles of simplicity, clarity, and generality (we will put more weight on these as we move forward with assignments and the project).</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Engs50 (CS50) -- Dartmouth College</h2>

    <p> <font size=-1>
    	This version of the course is based upon those designed by
    	Professors Palmer, Kotz, Zhou, Campbell, and Balkcom.
	I am deeply indebted to these outstanding educators.
    -- <a href="https://engineering.dartmouth.edu/people/faculty/stephen-taylor/">Stephen Taylor</a>
       </font>
    </p>
    <p><small>This page was last updated on <strong>2018-10-10</strong> at <strong>18:07</strong>.</small></p>
  </div>

</footer>


  </body>

</html>

